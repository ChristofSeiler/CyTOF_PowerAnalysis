---
title: "Classification"
output: html_document
author: Christof Seiler
date: April, 2017
params:
  treatment: "CSW_plus_HIV_plus_ART_plus"
  control: "CSW_plus_HIV_plus_ART_minus"
  fdr: "0.01"
  sample_file: "sample_table.csv"
  marker_file: "markers.csv"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Goal

We use logistic regression to predict different cells conditions from CyTOF markers.

## Input Parameters

```{r}
params
```

## Load Packages

```{r load_packages}
library(ggplot2)
library(reshape2)
library(magrittr)
library(stringr)
library(flowCore)
library(mbest)
library(ggfortify)
library(GGally)
theme_set(theme_bw())
```

## Load Data

Load sample table.

```{r}
sample_table = read.csv(params$sample_file)
sample_table$file_name = as.character(sample_table$file_name)
head(sample_table)
```

Load samples text files.

```{r import}
sample_list = lapply(sample_table$file_name,function(file_name_fcs) {
  fcsB = read.FCS(file_name_fcs,transformation = FALSE)
  marker_names = colnames(fcsB)[str_detect(colnames(fcsB),"[0-9]{1}Di")]
  marker_names = c(marker_names,"HLA-DR tot")
  marker_ids = which(colnames(fcsB) %in% marker_names)
  asinhT = arcsinhTransform(a = 0, b = 1/5, c = 0)
  transl = transformList(marker_names, asinhT)
  fcsBT = transform(fcsB[,marker_ids], transl)
  fcsBT@exprs
})
```

## Logistic Regression

Compare two levels of one variable while conditioning on the other two experimental conditions.

```{r}
subset_ids = which(sample_table$group == params$treatment | sample_table$group == params$control)
sample_table = sample_table[subset_ids,]
sample_table = droplevels(sample_table)
sample_list = sample_list[subset_ids]
```

Logistic regression on all cells. Combine all samples into one data frame.

```{r}
combine_samples = function(sample_id) {
  sample_info = sample_table[sample_id,]
  cat(as.character(sample_info$file_name),"\n")
  sample = sample_list[[sample_id]]
  rownames(sample_info) = NULL
  data.frame(sample,sample_info)
}
df_samples = lapply(1:length(sample_list),combine_samples) %>%
  do.call(rbind,.)
cell_count = table(df_samples$donor)
df_cell_count = data.frame(cell_count)
names(df_cell_count) = c("donor","cell_count")
ggplot(data=df_cell_count, aes(x=donor, y=cell_count)) +
  geom_bar(stat="identity") +
  theme(axis.text.x = element_text(angle=60, vjust=0.5))
```

Remove samples with less than 2500 cells.

```{r}
keepers = df_cell_count$donor[which(df_cell_count$cell_count > 4999)]
length(keepers)
df_samples = subset(df_samples,donor %in% keepers) %>% droplevels
table(df_samples$donor)
```

Change marker name from isotope name to protein name.

```{r}
markers = read.csv(params$marker_file,stringsAsFactors = FALSE)
markers$type = as.factor(markers$type)
for(i in 1:length(markers$isotope)) {
  isotope_name = markers$isotope[i]
  col_id = str_detect(string = names(df_samples),
                      pattern = as.character(isotope_name)) %>% which
  names(df_samples)[col_id] = markers$protein_name[i]
}
```

Subsample to 5000 cells per donor.

```{r}
set.seed(27261)
subsample_ids = lapply(levels(df_samples$donor),function(donor_id) {
  all_ids = which(df_samples$donor == donor_id)
  sample(x = all_ids,size = 5000)
}) %>% unlist
df_samples = df_samples[subsample_ids,]
table(df_samples$donor)
```

Visualize all proteins for one donor.

```{r fig.height=9,fig.width=10}
num_markers = ncol(df_samples)-ncol(sample_table)
df_samples_subset = data.frame(df_samples[,1:num_markers],
                               donor = df_samples$donor,
                               group = df_samples$group)
df_samples_subset_long = melt(df_samples_subset,id = c("donor","group"))
ggplot(df_samples_subset_long, aes(x = value,y = ..scaled..,shape = donor,color = group)) + 
  geom_density() + 
  facet_wrap(~ variable,ncol = 8) +
  xlab("arcsinh transformed counts") +
  theme(legend.position = "bottom")
```

Plotting function to visuzlize fixed effects.

```{r}
plot_glm = function(res_glm) {
  num_explanatory = nrow(summary(res_glm)$coefficient)-1
  adj_alpha = 0.05/num_explanatory
  ci = qnorm(1-adj_alpha/2)
  coeff = summary(res_glm)$coefficient[2:nrow(summary(res_glm)$coefficient),]
  # add protein name
  coeff = data.frame(coeff,protein_name=rownames(coeff))
  # sort according to z-value
  coeff$protein_name = factor(coeff$protein_name, 
                              levels = coeff$protein_name[order(abs(coeff$z.value),
                                                                decreasing = FALSE)])
  coeff = data.frame(coeff,
    high=coeff$Estimate+ci*coeff$Std..Error,
    low=coeff$Estimate-ci*coeff$Std..Error)
  response_name = strsplit(as.character(summary(res_glm)$call[2]),
                           split = "~") %>% unlist %>% .[1]
  print(
    ggplot(coeff, aes(x=protein_name, y=Estimate)) + 
      geom_hline(yintercept = 0, col = "red") + 
      geom_point() + 
      geom_segment(mapping=aes(x=protein_name, y=low, xend=protein_name, yend=high)) + 
      ylab("log-odds") + 
      theme(plot.title = element_text(hjust = 0.5)) +
      coord_flip()
  )
}
```

We use the package ``glm`` to setup a logistic regression model. The response variable are the log-odds and the explantory variables are markers. Log-odds are logarithm of ratios of two probabilites: the probabliliy that a cell is B (encoded as 1) over the probability that a cell is A (encoded as 0). This can be written mathematically as
$$\log\left(\frac{P(\text{cell is treatment})}{P(\text{cell is control})}\right) = \beta_0 + \beta_{1} \times \text{BCKG190Di} + \dots + \beta_{48} \times \text{Yb176Di}.$$

```{r}
fdr = as.numeric(params$fdr)
contrasts(df_samples$group)
markers_str = paste0(markers$protein_name,collapse = " + ")
# fixed effects only
formula = as.formula( paste("group ~ ",markers_str) )
formula
res_glm = glm(formula,family = binomial(link='logit'), data = df_samples)
pvalues = summary(res_glm)$coefficients[-1,4]
selected_marker_ids = which(p.adjust(pvalues,method = "BH") < fdr)
pvalues_adj = pvalues[selected_marker_ids]
pvalues_adj
plot_glm(res_glm)
```

Generalized linear mixed effect model that accounts for the variablity at the subjects level. We are only interested in those markers that are significantly associated at the population level, i.e., the fixed effects part.

```{r}
# mixed effects
# formula not working, workaround use parse command
formula_expr = parse(text = paste0("mhglm(",
                              paste("group ~",markers_str,"+",paste0("(",markers_str," | donor),")),
                              "family = binomial(link='logit'),",
                              "data = df_samples,",
                              "control = mhglm.control(parallel = TRUE,fit.method = 'firthglm.fit'))"))
formula_expr
res_mhglm = eval(formula_expr)
# --- too slow
#res_glm = glmer(formula,family = binomial(link='logit'), data = df_samples)
# ---
pvalues = summary(res_mhglm)$coefficients[-1,4]
pvalues_adj = p.adjust(pvalues,method = "BH")
results = data.frame(markers,pvalues,pvalues_adj)
results[order(results$pvalues),]
results_selected = subset(results,pvalues_adj < fdr)
results_selected
plot_glm(res_mhglm)
```

Markers with **positive coefficients** tell us that an increase in the associated marker **increases the log-odds**. Markers with **negative coefficients** tell us that an increase in the associated marker **decreases the log-odds**.

## Visualization of Important Markers

Only render if more than two markers are significant.

```{r}
column_ids = sapply(results_selected$protein_name,function(name) which(name == names(df_samples)))
if(length(column_ids) < 2) knitr::knit_exit()
```

Use information (condition, cell count, etc.) about each sample for annotation. Prepare data.

```{r}
subsample_ids = lapply(levels(df_samples$donor),function(donor_id) {
  all_ids = which(df_samples$donor == donor_id)
  sample(x = all_ids,size = round(10000/length(levels(df_samples$donor))))
}) %>% unlist
#subsample_ids = sample(x = nrow(df_samples),
#                       size = 10000,
#                       replace = FALSE)
df_samples_subset = df_samples[subsample_ids,column_ids]
df_info = df_samples[subsample_ids,names(sample_table)]
res_pca = prcomp(df_samples_subset,scale. = FALSE)
screeplot(res_pca)
```

PCA plots.

```{r fig.height=6,fig.width=8}
plot_pca = function(var_name) {
  var_explained = sapply(1:2,function(pc) 
    round(100*res_pca$sdev[pc]^2/sum(res_pca$sdev^2),digits = 1))
  autoplot(res_pca, 
           data = df_info, 
           colour = var_name, 
           loadings = TRUE, 
           loadings.label = TRUE,
           loadings.colour = "black",
           loadings.label.colour = "black",
           loadings.label.repel = FALSE,
           alpha = 0.5,
           xlab = paste0("PC1 (",var_explained[1],"%)"),
           ylab = paste0("PC2 (",var_explained[2],"%)"))
}
plot_pca("group")
plot_pca("donor")
plot_pca("date")
```

## Session Info

```{r session_info}
sessionInfo()
```
